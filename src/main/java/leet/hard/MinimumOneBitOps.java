package leet.hard;

public class MinimumOneBitOps {
    public static void main(String[] args) {
        System.out.println(minimumOneBitOperations(3));
    }
//    gray code; time: O(logn), space: O(1)
    public static int minimumOneBitOperations(int n) {
        int ans = n;
        ans ^= ans >> 16;
        ans ^= ans >> 8;
        ans ^= ans >> 4;
        ans ^= ans >> 2;
        ans ^= ans >> 1;
        return ans;
    }
}

/*
Given an integer n, you must transform it into 0 using the following operations any number of times:
Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.
Example 1:
Input: n = 3
Output: 2
Explanation: The binary representation of 3 is "11".
"11" -> "01" with the 2nd operation since the 0th bit is 1.
"01" -> "00" with the 1st operation.
Example 2:
Input: n = 6
Output: 4
Explanation: The binary representation of 6 is "110".
"110" -> "010" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.
"010" -> "011" with the 1st operation.
"011" -> "001" with the 2nd operation since the 0th bit is 1.
"001" -> "000" with the 1st operation.
Constraints:
0 <= n <= 109


Gray Code:

Complexity Analysis

Time complexity: O(logn)

The bit operations require logarithmic time. As we are always performing 10 operations (5 XORs, 5 shifts), the time complexity is O(logn).
However, we should note that the reason we are able to hardcode these 5 lines is because we know the input is a 32-bit integer. What if we wanted to develop an algorithm that could handle an arbitrarily large integer?
The number of logarithmic-time operations we would require is logarithmic with the number of bits, which is logarithmic with nnn. Thus, the time complexity would be O(log(logn)â‹…logn).
As log(logn) grows extremely slowly, this is a very efficient algorithm. For log(logn) to grow to even a value of 100 would require n to have 2^100
100 bits, a number so large it could not be explicitly written in any physical format within the observable universe. As such, this term could be considered a constant for any practical value of n.
Space complexity: O(1)
We aren't using any extra space. The previous approach's analysis does not apply here since we don't count the answer as part of the space complexity.
You may notice that the two operations given in the problem are capable only of changing exactly one bit at a time. Thus, any sequence of numbers generated by these operations must also be a Gray code!
Although there can be many Gray codes, the standard encoding actually follows the exact same ordering as one that would be produced by the operations given in this problem.
Thus, this problem is actually equivalent to finding the index of nnn in the standard Gray code sequence that starts from 0, since reducing n to 0 is equivalent to converting 0 to n.

 */